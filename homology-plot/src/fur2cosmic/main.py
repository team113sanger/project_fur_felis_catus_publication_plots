import typing as t
import os
import re
from urllib.parse import urljoin
from pathlib import Path
import json

import requests
import pandas as pd
import matplotlib.pyplot as plt
from Bio.Seq import Seq


from fur2cosmic import constants as C
import fur2cosmic.data
from fur2cosmic.exceptions import GeneIDNotFoundError, NoHomologyDataError
from fur2cosmic.utils.logging_utils import get_package_logger

if t.TYPE_CHECKING:
    from matplotlib.figure import Figure

# CONSTANTS & GLOBALS

LOGGER = get_package_logger()
JSON_FILE = fur2cosmic.data.get_non_ensembly_homology_json()


# FUNCTIONS


def get_study_color(study):
    return C.GLOBAL_STUDY_COLORS.get(study, (0, 0, 1))  # fallback to blue


# -----------------------------
# 1. HELPER FUNCTIONS (API & NUCLEOTIDE ALIGNMENT)
# -----------------------------


def fetch_endpoint(server, request, content_type, parameters=None):
    if parameters is None:
        parameters = {}
    endpoint_url = urljoin(server, request)
    headers = {"Accept": content_type}
    r = requests.get(endpoint_url, params=parameters, headers=headers)
    r.raise_for_status()
    if "application/json" in content_type:
        return r.json()
    else:
        return r.text


def get_gene_id(gene_symbol: str, species: str) -> str:
    """Look up an Ensembl gene ID for a given symbol and species."""
    request = f"/xrefs/symbol/{species}/{gene_symbol}"
    content_type = "application/json"
    response = fetch_endpoint(C.ENSEMBL_SERVER, request, content_type)
    if response and isinstance(response, list) and response[0].get("id"):
        return response[0]["id"]
    else:
        errmsg = f"Gene ID not found for {gene_symbol!r} in {species!r}"
        LOGGER.error(errmsg)
        LOGGER.error(f"JSON data from response: {response}")
        raise GeneIDNotFoundError(errmsg)


def is_gene_in_json(gene_name: str) -> bool:
    if not Path(JSON_FILE).is_file():
        return False
    with open(JSON_FILE) as f:
        data = json.load(f)
    return gene_name in data


def get_nucleotide_alignment_via_json(
    gene_symbol: str, source_species: str, target_species: str
) -> t.Tuple[str, str]:
    """
    Retrieve a cDNA (nucleotide) alignment from a local JSON file.

    This file was generated by running clustalw2 on the cDNA sequences of the two species.
    """
    with open(JSON_FILE) as f:
        data = json.load(f)
    clean_gene_symbol = gene_symbol.upper().strip()
    if not clean_gene_symbol in data:
        raise ValueError(f"Gene {gene_symbol} not found in JSON data.")
    gene_data = data.get(clean_gene_symbol, {})
    if not gene_data:
        raise ValueError(f"No data found for gene {clean_gene_symbol} in JSON.")
    if source_species not in gene_data:
        raise ValueError(f"No data found for {source_species} in JSON.")
    if target_species not in gene_data:
        raise ValueError(f"No data found for {target_species} in JSON.")

    method = "CLUSTAL"

    human_cdna_aln = gene_data[source_species][method]
    feline_cdna_aln = gene_data[target_species][method]
    return human_cdna_aln, feline_cdna_aln


def get_nucleotide_alignment_via_ensembl(
    query_species: str, target_species: str, gene_id: str
):
    """
    Retrieve a cDNA (nucleotide) alignment from Ensembl REST by specifying sequence=cdna.
    Returns (human_cdna_aln, feline_cdna_aln) as aligned strings (with '-' for gaps).
    """
    request = f"/homology/id/{query_species}/{gene_id}"
    content_type = "application/json"
    parameters = {"target_species": target_species, "sequence": "cdna"}
    response = fetch_endpoint(
        C.ENSEMBL_SERVER, request, content_type, parameters=parameters
    )
    # Check if the homology data is available, by drilling down into the response structure
    if (
        "data" not in response
        or not response["data"]
        or "homologies" not in response["data"][0]
        or not response["data"][0]["homologies"]
    ):
        err_msg = f"No homology data found for {query_species!r} -> {target_species!r} alignment, gene ID: {gene_id!r}"
        LOGGER.error(err_msg)
        LOGGER.error(f"JSON data from response: {response}")
        raise NoHomologyDataError(err_msg)
    data = response["data"][0]["homologies"][0]
    human_nuc_aln = data["source"]["align_seq"]
    feline_nuc_aln = data["target"]["align_seq"]
    return human_nuc_aln, feline_nuc_aln


def build_nuc_position_mapping(human_nuc_aln: str, feline_nuc_aln: str) -> dict:
    """
    Build a dictionary mapping feline nucleotide positions (ungapped) to human nucleotide positions (ungapped).
    Both positions are 1-indexed. Gaps ('-') are skipped.

    Key: Feline nucleotide position (1-indexed)
    Value: Human nucleotide position (1-indexed)
    """
    mapping = {}
    human_pos = 0
    feline_pos = 0
    for h_nuc, f_nuc in zip(human_nuc_aln, feline_nuc_aln):
        if f_nuc != "-":
            feline_pos += 1
        if h_nuc != "-":
            human_pos += 1
        if f_nuc != "-" and h_nuc != "-":
            mapping[feline_pos] = human_pos
    return mapping


# -----------------------------
# 2. HELPER FUNCTIONS (Reading COSMIC & Feline MAF NUCLEOTIDE MUTATIONS)
# -----------------------------
def read_cosmic_data(cosmic_file: t.Union[str, Path], gene_symbol: str) -> pd.DataFrame:
    """
    Read COSMIC data, filter to the given gene, and retain only simple protein mutations.
    Extracts numeric residue positions from 'MUTATION_AA' and aggregates counts per position.
    Returns a DataFrame with columns: [Human_Position, Count].
    """
    # Only read the columns we need
    cosmic_df = pd.read_csv(
        cosmic_file, sep="\t", usecols=["GENE_SYMBOL", "MUTATION_AA"], low_memory=False
    )

    # Filter to the relevant gene symbol
    cosmic_df = cosmic_df[cosmic_df["GENE_SYMBOL"] == gene_symbol]

    # Filter out nulls early
    cosmic_df = cosmic_df.dropna(subset=["MUTATION_AA"])

    # Use vectorized string operations instead of apply with lambda
    pattern = r"^p\.[A-Z](\d+)([A-Z]|\*)$"
    mask = cosmic_df["MUTATION_AA"].str.match(pattern)
    cosmic_df = cosmic_df[mask]

    # Extract positions using vectorized string operations
    cosmic_df["Human_Position"] = (
        cosmic_df["MUTATION_AA"].str.extract(r"p\.[A-Z](\d+)")[0].astype(int)
    )

    # Aggregate and count
    cosmic_agg = cosmic_df.groupby("Human_Position").size().reset_index(name="Count")

    return cosmic_agg


def extract_study_from_filename(file_path: t.Union[str, Path]) -> str:
    """
    Extract a short study/tumour type ID from the MAF filename.
    e.g., ".../keep_vaf_size_filt_matched_6555_2711.finalised.maf" -> "6555_2711"
    """
    base = os.path.basename(file_path)
    match = re.search(r"(\d+_\d+)", base)
    return match.group(1) if match else "Unknown"


def extract_tumour_type_from_study(study_id: str) -> str:
    """
    Extract the tumour type from a study ID using the global mapping.
    """
    return C.STUDY_ID_TO_TUMOUR_TYPE_DICT.get(study_id, "Unknown")


def parse_protein_mutation(hgvsp: str) -> t.Optional[t.Tuple[str, int, str]]:
    """
    Parse a simple protein mutation in HGVSp format.
    Expected input:
      - Possibly with transcript info: "ENSFCAP00000008332.5:p.Lys1156Arg"
      - Or just: "p.Lys1156Arg"
    """


def parse_nucleotide_mutation(hgvsc: str) -> t.Optional[t.Tuple[int, str, str]]:
    """
    Parse a simple cDNA mutation in HGVSc format.
    Expected input:
      - Possibly with transcript info: "ENSFCAT00000050290.1:c.2567C>G"
      - Or just: "c.2567C>G"
    Returns (position, ref, alt) if the mutation is a simple substitution (e.g., c.2567C>G),
    or None if it does not match.
    """
    mutation_part = hgvsc.split(":")[-1].strip()
    pattern = re.compile(r"^c\.(\d+)([ACGT])>([ACGT])$")
    m = pattern.match(mutation_part)
    if m:
        pos = int(m.group(1))  # Nucleotide position
        ref = str(m.group(2))  # Reference nucleotide (before > symbol)
        alt = str(m.group(3))  # Alternate nucleotide (after > symbol)
        return pos, ref, alt
    else:
        return None


def apply_nuc_mutation(cdna: str, pos: int, alt: str) -> str:
    """
    Apply a nucleotide substitution at a given 1-indexed position in a cDNA sequence.
    Returns the mutated cDNA sequence.
    """
    return cdna[: pos - 1] + alt + cdna[pos:]


def determine_protein_change(wt_prot: str, mut_prot: str):
    """
    Compare wild-type and mutated protein sequences and return a simple protein change in HGVS format,
    e.g. "p.E41K" if exactly one residue differs.
    Returns None if there is not exactly one amino acid substitution.
    """
    if len(wt_prot) != len(mut_prot):
        return None
    diffs = [(i, a, b) for i, (a, b) in enumerate(zip(wt_prot, mut_prot)) if a != b]
    if len(diffs) != 1:
        return None
    i, wt_aa, mut_aa = diffs[0]
    return f"p.{wt_aa}{i+1}{mut_aa}"


def determine_dna_change(wt_cdna: str, mut_cdna: str):
    """
    Compare wild-type and mutated cDNA sequences and return a simple DNA change in HGVS format,
    e.g. "c.123A>T" if exactly one nucleotide differs.
    Returns None if there is not exactly one nucleotide substitution.
    """
    if len(wt_cdna) != len(mut_cdna):
        return None
    diffs = [(i, a, b) for i, (a, b) in enumerate(zip(wt_cdna, mut_cdna)) if a != b]
    if len(diffs) != 1:
        return None
    i, wt_nuc, mut_nuc = diffs[0]
    return f"c.{i+1}{wt_nuc}>{mut_nuc}"


def map_nuc_mutations_from_maf(  # noqa: C901
    maf_file: t.Union[str, Path], gene_symbol: str, nuc_mapping: dict, human_cdna: str
) -> pd.DataFrame:
    """
    Process a feline MAF file containing nucleotide mutations (HGVSc),
    map each feline nucleotide mutation to the corresponding human nucleotide position using nuc_mapping,
    apply the mutation to the human cDNA, translate to protein, and deduce the protein change.
    Returns a DataFrame with columns: [Feline_Nuc_Pos, Human_Nuc_Pos, Protein_Change, Study].
    Only simple substitutions (e.g., c.123A>T) are processed.
    """
    df = pd.read_csv(maf_file, sep="\t", comment="#", low_memory=False)
    df = df[df["Hugo_Symbol"] == gene_symbol].copy()
    LOGGER.info(f"Processing {len(df)} records from {maf_file}")
    if "HGVSc" not in df.columns:
        raise ValueError(
            f"MAF file {maf_file} missing HGVSc column for nucleotide mutations."
        )

    records = []
    study = extract_study_from_filename(maf_file)
    tumour_type = extract_tumour_type_from_study(study)
    for _, row in df.iterrows():
        hgvsc = str(row["HGVSc"])
        parsed_hgscv = parse_nucleotide_mutation(hgvsc)

        if not parsed_hgscv:
            LOGGER.warning(f"Skipping non-snv HGVSc: {hgvsc}")
            continue
        feline_nuc_pos, ref, alt = parsed_hgscv
        if feline_nuc_pos not in nuc_mapping:
            LOGGER.warning(
                f"Skipping feline position not in mapping (shared nucleotide positions): {feline_nuc_pos}"
            )
            continue
        human_nuc_pos = nuc_mapping[feline_nuc_pos]
        if human_nuc_pos > len(human_cdna):
            LOGGER.warning(
                f"Skipping feline position mapped to out-of-range max human position: {feline_nuc_pos}"
            )
            continue

        # Fetch the representation of the mutation in the context of the original species
        protein_change_original = row["HGVSp_Short"].strip()
        dna_change_original = f"c.{feline_nuc_pos}{ref}>{alt}"

        # Generate the representation of the mutation in the context of the human species
        mutated_cdna_humanized = apply_nuc_mutation(human_cdna, human_nuc_pos, alt)
        wt_prot_humanized = str(Seq(human_cdna).translate(to_stop=True))
        mut_prot_humanized = str(Seq(mutated_cdna_humanized).translate(to_stop=True))
        dna_change_humanized = determine_dna_change(human_cdna, mutated_cdna_humanized)
        protein_change_humanized = determine_protein_change(
            wt_prot_humanized, mut_prot_humanized
        )

        if not protein_change_humanized:
            continue

        records.append(
            {
                C.COL_OUTPUT__FELINE_NUC_POS: feline_nuc_pos,
                C.COL_OUTPUT__HUMAN_NUC_POS: human_nuc_pos,
                C.COL_PATIENT_ID: row["Tumor_Sample_Barcode"],
                C.COL_OUTPUT__DNA_CHANGE_ORIGINAL: dna_change_original,
                C.COL_OUTPUT__PROTEIN_CHANGE_ORIGINAL: protein_change_original,
                C.COL_OUTPUT__DNA_CHANGE_AS_HUMAN: dna_change_humanized,
                C.COL_OUTPUT__PROTEIN_CHANGE_AS_HUMAN: protein_change_humanized,
                C.COL_OUTPUT__STUDY: study,
                C.COL_OUTPUT__TUMOUR_TYPE: tumour_type,
            }
        )
    return pd.DataFrame(records)


def concatenate_feline_mutation_data(
    gene_symbol: str,
    maf_files: t.Sequence[t.Union[str, Path]],
    nuc_mapping: t.Dict[int, int],
    human_cdna: str,
) -> pd.DataFrame:
    """
    Create a DataFrame that iterates over all MAF files, extracting feline
    mutations and mapping them to human.

    Args:
        gene_symbol (str): HUGO gene symbol to analyze, e.g., TP53.
        maf_files (list): List of MAF files containing feline mutations.
        nuc_mapping (dict): Mapping of feline nucleotide positions to human nucleotide positions.
        human_cdna (str): Human cDNA sequence.

    Returns:
        pd.DataFrame: DataFrame with columns:
    """
    all_feline_records = []
    for maf_file in maf_files:
        df_mapped = map_nuc_mutations_from_maf(
            maf_file, gene_symbol, nuc_mapping, human_cdna
        )
        if not df_mapped.empty:
            all_feline_records.append(df_mapped)
    if all_feline_records:
        df_feline_all = pd.concat(all_feline_records, ignore_index=True)
    else:
        df_feline_all = pd.DataFrame(
            columns=[
                C.COL_OUTPUT__FELINE_NUC_POS,
                C.COL_OUTPUT__HUMAN_NUC_POS,
                C.COL_PATIENT_ID,
                C.COL_OUTPUT__DNA_CHANGE_ORIGINAL,
                C.COL_OUTPUT__PROTEIN_CHANGE_ORIGINAL,
                C.COL_OUTPUT__DNA_CHANGE_AS_HUMAN,
                C.COL_OUTPUT__PROTEIN_CHANGE_AS_HUMAN,
                C.COL_OUTPUT__STUDY,
                C.COL_OUTPUT__TUMOUR_TYPE,
            ]
        )

    return df_feline_all


# -----------------------------
# 3. PLOTTING FUNCTIONS
# -----------------------------
def extract_protein_position(protein_change: str):
    """
    Extract the numeric residue position from a protein change (e.g., "p.E41K" -> 41).
    """
    match = re.search(r"p\.[A-Z](\d+)", str(protein_change))
    return int(match.group(1)) if match else None


def plot_nuc_mapped_vs_cosmic(
    cosmic_agg: pd.DataFrame,
    feline_prot_df: pd.DataFrame,
    gene_symbol: str,
    use_json: bool = False,
) -> t.Optional["Figure"]:
    """
    Create two subplots:
      - TOP: COSMIC protein mutations aggregated by residue, with lollipops pointing up.
             Uses a colorblind-friendly palette: orange for unique, blue for matching.
      - BOTTOM: Mapped feline protein mutations aggregated by protein residue and study,
                with lollipops pointing down (inverted y-axis) and colored by study.
                Marker shapes: squares for positions matching COSMIC and circles for unique.
      The legend shows:
          - COSMIC unique (orange) and COSMIC match (blue)
          - Each tumour type (mapped from study IDs)
          - Feline marker shapes: circle = unique, square = matching
      The legend is placed outside the plot.
    """
    # Aggregate feline mapped mutations by protein position and study.
    feline_prot_df = feline_prot_df.copy()
    feline_prot_df["Protein_Position"] = feline_prot_df[
        C.COL_OUTPUT__PROTEIN_CHANGE_AS_HUMAN
    ].apply(extract_protein_position)
    feline_prot_df = feline_prot_df[feline_prot_df["Protein_Position"].notnull()]
    feline_agg = (
        feline_prot_df.groupby(["Protein_Position", C.COL_OUTPUT__STUDY])
        .size()
        .reset_index(name="Count")
    )

    # For COSMIC, assume positions are already protein positions.
    cosmic_agg["Protein_Position"] = cosmic_agg["Human_Position"]

    cosmic_positions = set(cosmic_agg["Protein_Position"].dropna().unique())
    feline_positions = set(feline_agg["Protein_Position"].dropna().unique())
    all_positions = cosmic_positions.union(feline_positions)
    if not all_positions:
        LOGGER.warning("Cannot create plot as there are no protein positions.")
        return
    x_min, x_max = min(all_positions) - 5, max(all_positions) + 5

    matching_positions = cosmic_positions.intersection(feline_positions)

    # Create subplots
    fig = plt.figure(figsize=(15, 8))
    gs = fig.add_gridspec(2, 1)
    ax_cosmic = fig.add_subplot(gs[0])
    ax_feline = fig.add_subplot(gs[1], sharex=ax_cosmic)

    # TOP SUBPLOT: COSMIC panel with colorblind-friendly palette
    cosmic_max = cosmic_agg["Count"].max() if not cosmic_agg.empty else 1
    ax_cosmic.set_xlim(x_min, x_max)
    ax_cosmic.set_ylim(0, cosmic_max * 1.2)
    ax_cosmic.set_ylabel("COSMIC Count (Up)")
    title = f"{gene_symbol} Mutations: COSMIC vs. Mapped Feline (Nucleotide-based)"
    if use_json:
        title += " (not Ensembl API)"
    ax_cosmic.set_title(title)

    # Use orange for COSMIC unique, blue for COSMIC matching.
    for _, row in cosmic_agg.iterrows():
        pos = row["Protein_Position"]
        count = row["Count"]
        color = "blue" if pos in matching_positions else "orange"
        ax_cosmic.vlines(pos, 0, count, color=color, linewidth=2)
        ax_cosmic.plot(pos, count, "o", color=color, markersize=6)

    # BOTTOM SUBPLOT: Feline panel
    feline_max = feline_agg["Count"].max() if not feline_agg.empty else 1
    ax_feline.set_xlim(x_min, x_max)
    ax_feline.set_ylim(0, feline_max * 1.2)
    ax_feline.invert_yaxis()  # Invert y-axis so counts appear downward
    ax_feline.set_ylabel("Feline Count (Down)")

    # Use the global study color mapping (global_study_colors) to assign colours
    studies = sorted(list(feline_agg[C.COL_OUTPUT__STUDY].unique()))
    study_colors = {s: get_study_color(s) for s in studies}

    for _, row in feline_agg.iterrows():
        pos = row["Protein_Position"]
        count = row["Count"]
        study = row["Study"]
        color = get_study_color(study)
        marker = "s" if pos in matching_positions else "o"
        ax_feline.vlines(pos, 0, count, color=color, linewidth=2)
        ax_feline.plot(pos, count, marker=marker, color=color, markersize=8)

    ax_feline.set_xlabel("Protein Residue Position (Human numbering)")

    # Create legend handles:
    # COSMIC legend handles
    cosmic_unique = plt.Line2D(
        [0],
        [0],
        marker="o",
        color="w",
        markerfacecolor="orange",
        markersize=8,
        label="COSMIC unique",
    )
    cosmic_match = plt.Line2D(
        [0],
        [0],
        marker="o",
        color="w",
        markerfacecolor="blue",
        markersize=8,
        label="COSMIC match",
    )
    # Study legend handles (using tumour types from the dictionary)
    study_handles = [
        plt.Line2D(
            [0],
            [0],
            marker="o",
            color="w",
            markerfacecolor=study_colors[s],
            markersize=8,
            label=C.STUDY_ID_TO_TUMOUR_TYPE_DICT.get(s, s),
        )
        for s in studies
    ]
    # Feline marker shape legend handles:
    feline_unique = plt.Line2D(
        [0],
        [0],
        marker="o",
        color="k",
        linestyle="None",
        markersize=8,
        label="Feline unique (circle)",
    )
    feline_match = plt.Line2D(
        [0],
        [0],
        marker="s",
        color="k",
        linestyle="None",
        markersize=8,
        label="Feline match (square)",
    )

    handles = (
        [cosmic_unique, cosmic_match] + study_handles + [feline_unique, feline_match]
    )

    # Place legend with better positioning parameters
    fig.legend(
        handles=handles,
        title="Source",
        loc="center right",
        bbox_to_anchor=(0.9, 0.5),
        fontsize=10,
        title_fontsize=12,
        frameon=False,
        borderaxespad=1,
    )

    # Adjust subplot spacing to make room for legend
    fig.tight_layout()
    plt.subplots_adjust(right=0.75)  # Reserve 25% of figure width for legend
    return fig


# -----------------------------
# 4. MAIN SCRIPT
# -----------------------------
def main(
    gene_symbol: str,
    cosmic_file: t.Union[str, Path],
    maf_files: t.Sequence[t.Union[str, Path]],
    skip_plots: bool = False,
    use_json: bool = False,
) -> t.Tuple[pd.DataFrame, "t.Optional[Figure]"]:
    """
    Using nucleotide alignment to map feline nucleotide mutations from MAF files
    to human. The mapped nucleotide mutations are then translated to protein,
    and the resulting protein changes are compared with COSMIC data.

    This function does not write any files, but the return types can
    be used to write files if needed. See CLI usage for output file writing.

    Steps:
      1. Retrieve the cDNA (nucleotide) alignment between human and feline.
      2. Build a nucleotide mapping (feline -> human).
      3. Extract the human cDNA sequence (ungapped) from the alignment.
      4. For each feline MAF file:
           - Parse the simple nucleotide mutation from the "HGVSc" column (e.g., c.2567C>G).
           - Map the feline nucleotide position to human using the nucleotide mapping.
           - Apply the mutation to the human cDNA, translate to protein, and deduce the protein change.
      5a. Optionally (if plots are needed), read COSMIC data (filtered to simple protein mutations).
      5b. Optionally (if plots are needed), aggregate the mapped feline protein mutations and compare with COSMIC in a two-subplot plot:
           - COSMIC (top): lollipops pointing up; orange for unique and blue for matching positions.
           - Feline (bottom): lollipops pointing down, colored by study (using global study colors), with square markers for matching positions and circle markers for unique ones.
           - The legend shows tumour types (from STUDY_ID_TO_TUMOUR_TYPE_DICT) and explains marker shapes, placed outside the plot.

    Args:
        gene_symbol (str): HUGO gene symbol to analyze, e.g., TP53.
        cosmic_file (str or Path): Path to a COSMIC Cancer Mutation Census (CMC) data file.
        maf_files (list of str or Path): List of MAF files containing feline mutations.
        skip_plots (bool): If True, skip generating comparison plots.
        use_json (bool): If True, use local JSON data for nucleotide alignments not present in Ensembl API.

    Returns:
        tuple: A tuple containing:
            - pd.DataFrame): DataFrame with mapped feline protein mutations.
            - Figure or None: Figure object if plots are generated, else None.
    """
    # 1) Get gene id
    LOGGER.info(f"Retrieving Ensembl ID for {gene_symbol!r}")
    human_gene_id = get_gene_id(gene_symbol, "human")
    if not human_gene_id:
        raise ValueError(f"Could not retrieve Ensembl ID for {gene_symbol}")

    # 2) Get nucleotide alignment (cDNA) for human and feline
    LOGGER.info(f"Retrieving nucleotide alignment for {gene_symbol!r}")
    gene_in_json = is_gene_in_json(gene_symbol)
    if gene_in_json and use_json:
        LOGGER.info("Using JSON data for nucleotide alignment")
        human_nuc_aln, feline_nuc_aln = get_nucleotide_alignment_via_json(
            gene_symbol, source_species="human", target_species="felis_catus"
        )
    else:
        LOGGER.info("Using API data for nucleotide alignment")
        human_nuc_aln, feline_nuc_aln = get_nucleotide_alignment_via_ensembl(
            "human", "felis_catus", human_gene_id
        )
    if not human_nuc_aln or not feline_nuc_aln:
        raise ValueError("Could not retrieve nucleotide alignment from Ensembl.")

    # 3) Build nucleotide mapping and extract human cDNA (ungapped)
    LOGGER.info("Building nucleotide position mapping")
    nuc_mapping = build_nuc_position_mapping(human_nuc_aln, feline_nuc_aln)
    human_cdna = "".join([n for n in human_nuc_aln if n != "-"])
    feline_cdna = "".join([n for n in feline_nuc_aln if n != "-"])
    LOGGER.info(f"Human cDNA length (gapped): {len(human_nuc_aln)}")
    LOGGER.info(f"Feline cDNA length (gapped): {len(feline_nuc_aln)}")
    LOGGER.info(f"Human cDNA length (ungapped): {len(human_cdna)}")
    LOGGER.info(f"Feline cDNA length (ungapped): {len(feline_cdna)}")

    # 4) Process each feline MAF file for nucleotide mutations
    LOGGER.info(f"Processing feline MAF files for {gene_symbol!r}")
    df_feline_all = concatenate_feline_mutation_data(
        gene_symbol, maf_files, nuc_mapping, human_cdna
    )
    LOGGER.info(f"Found {len(df_feline_all)} mapped feline protein mutations.")

    if not skip_plots:
        # 5a) Read COSMIC data (filtered to simple protein mutations)
        LOGGER.info(f"Reading COSMIC data from {cosmic_file!r}")
        cosmic_agg = read_cosmic_data(cosmic_file, gene_symbol)

        # 5b) Plot the comparison of COSMIC vs. mapped feline protein mutations.
        LOGGER.info(f"Plotting COSMIC vs. feline protein mutations for {gene_symbol!r}")
        fig = plot_nuc_mapped_vs_cosmic(
            cosmic_agg, df_feline_all, gene_symbol, use_json=(gene_in_json and use_json)
        )
    else:
        LOGGER.info("Skipping plots as requested.")
        fig = None
    return (df_feline_all, fig)
